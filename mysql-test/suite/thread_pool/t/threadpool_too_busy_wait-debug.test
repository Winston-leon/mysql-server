--source suite/thread_pool/include/have_pool_of_threads.inc
--source include/have_debug.inc

# Test that existed connection may or may not be able to execute command, depending on the timing of io events's arrival

# initialize data
CREATE DATABASE db1;
CREATE TABLE db1.t1 (
    c1 int NOT NULL,
    c2 int NOT NULL,
    PRIMARY KEY (c1)
);
INSERT INTO db1.t1 (c1,c2) VALUES (1,11);
INSERT INTO db1.t1 (c1,c2) VALUES (2,22);
INSERT INTO db1.t1 (c1,c2) VALUES (3,33);

connect(extracon,127.0.0.1,root,,,$MASTER_EXTRA_PORT);
connect(conn0,127.0.0.1,root,,db1);
connect(conn1,127.0.0.1,root,,db1);
connect(conn2,127.0.0.1,root,,db1);
connect(conn3,127.0.0.1,root,,db1);
connect(conn4,127.0.0.1,root,,db1);

connection conn0;
START TRANSACTION;
SELECT * FROM db1.t1 WHERE c1=2 FOR UPDATE;
--sleep 1

connection conn1;
START TRANSACTION;
SEND SELECT * FROM db1.t1 WHERE c1=2 LOCK IN SHARE MODE;

connection conn2;
START TRANSACTION;
SEND SELECT * FROM db1.t1 WHERE c1=2 LOCK IN SHARE MODE;

# Test that listener polls 1 queue_event and process it. Verify it 2 times.
--let $counter=0
while ($counter<2)
{
    connection conn3;
    SEND SELECT 1;
    --sleep 1

    # ASSERT queue length = 0
    connection extracon;
    --let queue_length=`SELECT QUEUE_LENGTH FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS`
    --echo queue_length $queue_length

    connection conn3;
    REAP;

    --inc $counter
}

# Execute this command in thread pool handler, so that the next command will be first of the two required io events.
SET GLOBAL debug="+d,threadpool_io_poll_wait_at_least_2_events";
--sleep 1

# Test that listener polls 2 queue_events and process one of them, leaving the other in low priority queue

# First of the 2 required io events, listener will execute another io_poll_wait
connection conn3;
SEND SELECT 1;

# Disable threadpool_io_poll_wait_at_least_2_events
connection extracon;
SET GLOBAL debug="-d,threadpool_io_poll_wait_at_least_2_events";
--sleep 1

# Second of the two required io events, listener will deal with the 2 io_events, either process one of them or put both to queue.
connection conn4;
SEND SELECT 1;
--sleep 1

# ASSERT queue length = 1
connection extracon;
--let queue_length=`SELECT QUEUE_LENGTH FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS`
--echo queue_length $queue_length
# Test that under this circumstance, information offered by information schema is as expected
# I_S.THREAD_POOL_GROUPS
SELECT SUM(CONNECTIONS) FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS;
SELECT SUM(ACTIVE_THREADS) FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS;
SELECT SUM(STANDBY_THREADS) FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS;
SELECT SUM(QUEUE_LENGTH) FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS;
SELECT SUM(HAS_LISTENER) FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS;
SELECT SUM(IS_STALLED) FROM INFORMATION_SCHEMA.THREAD_POOL_GROUPS;
# I_S.THREAD_POOL_QUEUES
SELECT COUNT(*) FROM INFORMATION_SCHEMA.THREAD_POOL_QUEUES;

# Clean up
connection conn0;
ROLLBACK;

connection conn1;
REAP;
ROLLBACK;

connection conn2;
REAP;
ROLLBACK;

connection conn3;
REAP;

connection conn4;
REAP;

connection extracon;
--echo Clean up
DROP TABLE db1.t1;
DROP DATABASE db1;

disconnect conn0;
disconnect conn1;
disconnect conn2;
disconnect conn3;
disconnect conn4;
disconnect extracon;
